# Система «Розумний будинок».
Система має підтримувати різні типи пристроїв(освітлення, опалення, безпека, т.д.) і мати можливість легко додавати нові. Має бути реалізовано підтримку сценаріїв(різні дії пристроїв для різного часу доби, місяця), моніторинг, взаємодія пристроїв, реакція на зовнішні події. Проєкт повинен бути масштабованим та гнучким для можливості просто додавати новий функціонал.

## Патерни проєктування «Factory Method» і «Abstract Factory».
### Factory
Для створення пристроїв у системі та можливості гнучкої взаємодії між ними, необхідно створити об’єкти на пристрої, виокремити загальні характеристики, згрупувати методи створення пов’язаних пристроїв для різних зон(кухня, вітальня). Для цього підійдуть шаблони проектування Фабрика та Абстрактна Фабрика. Фабрика дозволить створити окремий клас для створення об’єктів з набором потрібних властивостей. Фабрика також підходить, тому що ми не знаємо одразу які об’єкти і скільки їх буде, цей патерн дозволить додавати їх без проблем. Об’єкти делегуються з базового, розширюючи їх можливості. Такими об’єктами в нас є розумні пристрої, які мають якісь базові характеристики(назва, включити/виключити), а далі розходяться по функціоналу, наприклад – термостат і лампа. Лампи в свою чергу складають ієрархію – звичайна – світлодіодна – RGB.<br>
•	Учасники патерну:<br>
•	Абстрактний клас Device, який визначає інтерфейс пристрою.<br>
•	Конкретні класи Lamp – LedLamp – RGBLamp і Thermostat представляють реалізацію класу Device.<br>
•	Абстрактний клас DeviceFactory, який визначає базові характеристики фабрики пристроїв.<br>
•	Конкретний клас ThermostatFactory і абстрактний клас LampFactory( + його похідні класи) визначають реалізацію створення пристроїв потрібного типу. 

### Abstract Factory
Для створення різних видів ламп було вирішено використати патерн «Абстрактна фабрика» для створення загального класу фабрики ламп і їх специфікацій для різних зон.<br>
Учасники:<br>
Абстрактний клас LampFactory визначає інтерфейс для створення ламп.<br>
Конкретні класи LedLamp – RGBLamp представляють реалізацію ламп.<br>
Конкретні класи для створення ламп KitchenLampFactory і LivingRoomLampFactory визначають методи і специфікації для створення потрібних ламп.<br>
Конкретні класи KitchetLampSpecification і LivingRoomLampSpecification дають додаткову інформацію щодо специфікації ламп. 


## Патерни проєктування «Prototype» і «Builder».
### Prototype
Для швидкого створення нових екземплярів пристроїв із попередньо налаштованими параметрами можна використати патерн Prototype.<br>
Учасники:<br>
Device – визначає інтерфейс для клонування методом Clone()<br>
LedLamp і RGBLamp, які реалізують метод Clone()

### Builder
Для поетапної збірки складних об’єктів пристроїв з конфігурацією великої кількості параметрів(рівень яскравості, колір, тип живлення) використаємо патерн Builder.
Учасники:<br>
RGBLamp – продукт, який має бути створений і має різні частини: колір, яскравість, потужність.<br>
RGBLampBuilder – визначає інтерфейс для створення RGBLamp<br>
BrightRedRGBLampBuilder, SemiBrightGreenRGBLampBuilder – конкретні реалізації будівельників.<br>
LampCreator – розпорядник, створює об’єкти використовуючи RGBLampBuilder.
 
## Поведінкові патерни Strategy, Observer і Command 
### Strategy
Патерн Strategy забезпечує динамічний вибір алгоритму керування розумним пристроєм залежно від вимог. 
Реалізуємо стратегії використання лампочок: Енергозберігаючий режим та Нормальний режим.<br>
Учасники патерну:<br>
•	Інтерфейс ILampOperationStrategy з методом Execute(Lamp)<br>
•	КласиEnergySaverMode, NormalMode, які реалізують інтерфейс ILampOpeartionStrategy.<br>
•	Класс Lamp, який має посилання на стратегію та метод ApplyStrategy для використання.

### Observer
За допомогою патерну Observer можна створити зв’язок між компонентами, розділивши їх на суб’єкти, за якими спостерігають і власне спостерігачів, які реагують на події суб’єктів. Можна реалізувати датчики та пристрої, які отримують від них інформацію.<br>
Учасники патерну:<br>
Інтерфейс IObservable представляє спостережуваний об’єкт, має 3 методи: AddObserver, RemoveObserver, NotifyObservers.<br>
Класс MotionSensor, який реалізує інтерфейс IObservable і представляє собою датчик руху.<br>
Інтерфейс IObserver представляє спостерігача, визначає метод Update(Object), який викликається спостережуваним об’єктом.<br>
Класи Lamp, SecuritySystem реалізують інтерфейс IObserver і реагують на рух, про який повідомляє MotionServer.

### Command
За допомогою патерну Command ми зможемо інкапсулювати фрагмент коду, що виконує певну дію у окремий об’єкт-команду. Такі команди можна буде згрупувати та виконувати як реакцію на окрему дію.<br>
Учасники патерну:<br>
Інтерфейс ICommand, представляє команду, визначає методи Execute та Undo.<br>
Класи TurnOnCommand, TurnOffCommand, SetHalfBrightnessCommand, які реалізують інтерфейс ICommand і представляють різні команди, які можна виконати над розумними пристроями.<br>
Класи Device, Lamp, які приймають ці команди.<br>
Клас RemoteCommandInvoker, який акумулює команди у список та виконує їх по черзі.

## Поведінкові патерни MacroCommand і Template method

### MacroCommand
Макрокоманди потрібні для інкапсуляції набору команд. Ми можемо її використати, коли хочемо мати окремі команди на якісь дії, але при цьому ж більш широку команду з використанням однієї команди, яка використовує декілька базових.<br>
Учасники:<br>
•	ICommand – інтерфейс, який реалізує інтерфейс команди та пропонує методи Execute, Undo.<br>
•	MacroCommand – клас, який реалізує цей інтерфейс і має властивість _commands, яка є списком команд. Також є метод AddCommand.

### Template method
За допомогою шаблонного методу ми визначимо алгоритм перевірки роботоспособності пристрою, який буде виконувати декілька етапів. Ці етапі схожі в різних розумних пристроях, тому їх можна винести в загальних клас і перевизначати в нащадках.<br>
Учасники:<br>
•	Device – абстрактний клас, який визначає основу розумного пристрою, реалізує шаблонні методи TurnOn, TurnOff, ConnectToNetwork, ExecuteMainFunction і метод OperateDevice, який викликає їх в конкретному порядку.<br>
•	Lamp, LedLamp, RGBLamp, Thermostat, MotionSensor, SecuritySystem – конкретні класи, які перевизначають потрібні методи.

## Патерни Iterator, State, Chain of Responsibility

### Iterator

У системах розумного будинку часто пристроїв групуються в кімнатах, які мають список пристроїв. Для того, щоб не порушувати інкапсуляцію, доречно зробити клас Room ітерабельним, для того щоб зручно працювати з списком пристроїв.<br>
Учасники:<br>
•	ISmartHomeIterator: визначає інтерфейс для обходу<br>
•	SmartHomeIterator: реалізація ітератору<br>
•	Room – клас кімнати, який має метод CreateIterator<br>

### State

Усі розумні пристрої перебувають в якомусь конкретному стані(Ввімкнений, Вимкнений, Очікує команди і т.д.). Було б непогано мати універсальний визначник цього стану. Для цього створимо базовий клас стану, який буде визначати методи про вхід/вихід з нього і метод, який визначає чи може пристрій у цьому стані виконати якусь команду.<br>
Учасники:<br>
•	Абстрактний клас DeviceState, який визначає методи OnEnter, OnExit, CanHandleCommand<br>
•	Наслідники OffState, OnState, ErrorState, ActiveState які визначають різні стани пристрою.<br>
•	Абстрактний клас Device, який визначає властивість CurrentState і оброблює переходи між ними. <br>

### Chain of Responsibility

Об’єднаємо усі елементи системи, створивши контролер розумного будинку, який буде мати змогу обробляти різні команди. Для гнучкості виконання команд використаємо патерн Chain of Responsibity, який дозволить створити ланцюжок обробників команд, який можна заповнити різними обробниками так, щоб команда завжди мала змогу виконатись(якісь з обробників не будуть мати змогу виконати команду через стан пристрою).<br>
Учасники:<br>
•	Абстрактний клас CommandProcessor – базовий клас обробника команд, який визначає методи SetNext(встановлення посилання на наступний обробник в ланцюжку), ProcessCommand (виконання команди, якщо це можливо і передача керування в наступний обробник, якщо це необхідно), CanProcessCommand (визначає чи може цей) обробник виконати таку команду.<br>
•	Класи StatusProcessor, FunctionCommandProcessor, LoggerProcessor які виконують різні види команд.<br>
•	Клас SmartHomeController – який має в собі Room, commandChain, методи для керування вмістом списку пристроїв та може надсилати команду пристрою по імені. <br>

## Патерни Interpreter, Mediator

### Interpreter

Для керування системи природними командами, наприклад, голосом, реалізуємо логіку обробки виразів. Створимо класи для нетермінальних і термінальних операцій, таких як "включити/виключити", "поставити яскравість", т.д.
Учасники:<br>
інтерфейс IExpression - має метод для обробки виразу в контексті<br>
SmartHomeContext - контекст виконання виразів, має посилання на контролер кімнат, змінні<br>
DeviceExpression, TurnOnExpression, TurnOffExpression, SetBrightness, SetColorExpression, SetTemperatureExpression, SequenceExpression - термінальні і нетермінальні вирази<br>
CommandParser - клас, який реалізує логіку розбиття початкового виразу на дерево термінальних і нетермінальних виразів<br>

### Mediator

Для зменшення зв'язності між пристроями, створимо клас медіатор для створення різних сценаріїв та масштбування. Таким чином пристрої напряму не знають про інші, лише через медіатор.<br>
Учасники:<br>
ISmartHomeMediator - інтерфейс, який визначає методи Register, Notify<br>
SmartHomeController - клас, який реалізує інтерфейс. Цей клас представляє хаб між пристроями і реалізує взаємодію між пристроями.<br>

## Патерни Memento, Visitor

### Memento
Для можливості відновити стан системи після її перезавантаження, реалізуємо патерн Memento, який буде зберігати стан пристроїв(кімнати з пристроями) і буде мати можливість відновлювати стан з історії<br>
Учасники:<br>
Device.DeviceMemento, Room.RoomMemento - класи для зберігання стану пристроїв і кімнати з пристроями відповідно<br>
Device, Room - класи, які мають стан
SmartHomeHistory - клас, який зберігає історію станів

### Visitor
На даному етапі у системі вже присутня велика ієрархія класів і для розширення функціоналу необхідно змінювати кожен клас, що порушує Single Responsibility і Open/Closed принципи. Тому для цієї мети реалізуємо шаблон Visitor.<br>
Учасники:<br>
ISmartHomeVisitor - інтерфейс, який визначає методи Visit для різних об'єктів<br>
StatusReportVisitor, EnergyConsumptionVisitor, ConfigurationValidatorVisitor - відвідувачі які реалізують функціонал збору статусів, потужностей, перевірка конфігурації<br>
